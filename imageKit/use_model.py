#!/usr/bin/env python
# -*- coding: utf-8 -*-

import argparse
import os
import sys
import numpy as np
from PIL import Image
import six
import six.moves.cPickle as pickle
import chainer
from chainer import serializers
import nin

parser = argparse.ArgumentParser(
            description='predict bukken photo type')
parser.add_argument('img_path', help='Path to bukken image')
parser.add_argument('--mean', '-m', default='mean.npy',
                            help='Path to the mean file (computed by compute_mean.py)')
parser.add_argument('--model', default='model',
                            help='the model that generated by train_imagenet.py')
parser.add_argument('--labels', default='image_label.csv',
                            help='csv file of bukken image labels')
args = parser.parse_args() 

# 平均画像読み込み
mean_image = pickle.load(open(args.mean, 'rb'))

# モデル読み込み
model = nin.NIN()
serializers.load_hdf5(args.model, model)

cropwidth = 256 - model.insize

def resize_image(raw_image):
    # 学習データサイズに変換
    if (raw_image.size[0] > 120 or raw_image.size[1] > 120) :
        raw_image.thumbnail([120, 120], Image.ANTIALIAS)
    
    # ndarrayに変換
    image_array = np.asarray(raw_image)
    
    # 画像繰り返しで256*256サイズに変換
    image_array = crop_image(image_array.copy())

    # さらにninモデルの入力サイズに変換
    image = image_array.transpose(2, 0, 1)
    top = left = cropwidth / 2
    bottom = model.insize + top
    right = model.insize + left

    image = image[:, top:bottom, left:right].astype(np.float32)
    image -= mean_image[:, top:bottom, left:right]
    image /= 255
    return image

# 画像のミラー&切り抜き
def crop_image(src) :
    target_shape = (256, 256)
    # mirror image
    while src.shape[0] < target_shape[0] or src.shape[1] < target_shape[1]:
       # print(src.shape)
        src = np.concatenate((np.fliplr(src), src), axis=1)
        src = np.concatenate((np.flipud(src), src), axis=0)
    src = src[:target_shape[0], :target_shape[1]]
    return src

# 解析結果の整理
def format_scores(scores_array) :
    res = []
    for x, scores in enumerate(scores_array) :
        scores = scores_array[x][:23]
        elements = []
        for line in open(args.labels):
            pair = line.rstrip().split(",")
            elements.append(pair[1])

        scoreDic = {}

        for y, score in enumerate(scores) :
            scoreDic[elements[y]] = score

        rank = []
        i = 0
        for k, v in sorted(scoreDic.items(), key=lambda x:x[1], reverse=True) :
            rank.append((k,v))
            i += 1
        res.append(rank)

    return res

# 画像読み込み
raw_image = Image.open(args.img_path)
fixed_image = resize_image(raw_image)
x = chainer.Variable(np.asarray([fixed_image]), volatile='on')

scores = model.predict(x)
formated_score = format_scores(scores.data)
for tupple in formated_score[0][:10]: 
    print("%-12s\t %.3f%% " %(tupple[0], tupple[1]*100.0 ))
